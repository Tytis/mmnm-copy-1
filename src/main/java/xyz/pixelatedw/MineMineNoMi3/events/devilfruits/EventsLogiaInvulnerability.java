package xyz.pixelatedw.MineMineNoMi3.events.devilfruits;

import cpw.mods.fml.common.eventhandler.SubscribeEvent;
import cpw.mods.fml.common.network.simpleimpl.IMessage;
import net.minecraft.block.Block;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityThrowable;
import net.minecraft.item.ItemStack;
import net.minecraft.util.DamageSource;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.entity.living.LivingEvent;
import xyz.pixelatedw.MineMineNoMi3.MainConfig;
import xyz.pixelatedw.MineMineNoMi3.api.WyHelper;
import xyz.pixelatedw.MineMineNoMi3.api.abilities.Ability;
import xyz.pixelatedw.MineMineNoMi3.api.abilities.AbilityAttribute;
import xyz.pixelatedw.MineMineNoMi3.api.abilities.AbilityProjectile;
import xyz.pixelatedw.MineMineNoMi3.api.abilities.extra.AbilityProperties;
import xyz.pixelatedw.MineMineNoMi3.api.network.WyNetworkHelper;
import xyz.pixelatedw.MineMineNoMi3.data.ExtendedEntityData;
import xyz.pixelatedw.MineMineNoMi3.entities.mobs.EntityNewMob;
import xyz.pixelatedw.MineMineNoMi3.helpers.DevilFruitsHelper;
import xyz.pixelatedw.MineMineNoMi3.lists.ListAttributes;
import xyz.pixelatedw.MineMineNoMi3.lists.ListEffects;
import xyz.pixelatedw.MineMineNoMi3.lists.ListMisc;
import xyz.pixelatedw.MineMineNoMi3.packets.PacketParticles;

public class EventsLogiaInvulnerability {
  @SubscribeEvent
  public void onEntityAttackEvent(LivingAttackEvent event) {
    EntityLivingBase entity = event.entityLiving;
    DamageSource damageSource = event.source;
    Entity sourceOfDamage = event.source.getSourceOfDamage();
    ItemStack heldItem = null;
    boolean entityIsLogia = false;
    String entityUsedFruit = "n/a";
    ExtendedEntityData props = ExtendedEntityData.get(entity);
    entityIsLogia = props.isLogia();
    entityUsedFruit = props.getUsedFruit();
    boolean attackerHasKairosekiWeapon = false;
    boolean attackerHasHaki = false;
    String attackerUsedFruit = "n/a";
    if (sourceOfDamage instanceof EntityPlayer) {
      ExtendedEntityData propz = ExtendedEntityData.get((EntityLivingBase)sourceOfDamage);
      heldItem = ((EntityPlayer)sourceOfDamage).getHeldItem();
      AbilityProperties ablProps = AbilityProperties.get((EntityPlayer)sourceOfDamage);
      Ability busoHaki = ablProps.getAbilityFromName(ListAttributes.BUSOSHOKU_HAKI_HARDENING.getAttributeName());
      Ability busoHakiFull = ablProps.getAbilityFromName(ListAttributes.BUSOSHOKU_HAKI_FULL_BODY_HARDENING.getAttributeName());
      attackerHasHaki = (((busoHaki != null && busoHaki.isPassiveActive()) || (busoHakiFull != null && busoHakiFull.isPassiveActive())) && heldItem == null);
      attackerUsedFruit = propz.getUsedFruit();
      if (heldItem != null) {
        Ability busoHakiImb = ablProps.getAbilityFromName(ListAttributes.BUSOSHOKU_HAKI_IMBUING.getAttributeName());
        attackerHasKairosekiWeapon = ((heldItem.isItemEnchanted() && EnchantmentHelper.getEnchantmentLevel(ListEffects.kairoseki.effectId, heldItem) > 0) || (busoHakiImb != null && busoHakiImb.isPassiveActive()));
        if (heldItem.getItem() == ListMisc.Jitte)
          attackerHasKairosekiWeapon = true; 
      } 
    } else if (sourceOfDamage instanceof EntityNewMob) {
      ExtendedEntityData propz = ExtendedEntityData.get((EntityLivingBase)sourceOfDamage);
      attackerHasHaki = propz.hasBusoHakiActive();
      heldItem = ((EntityNewMob)sourceOfDamage).getHeldItem();
      attackerUsedFruit = propz.getUsedFruit();
      if (heldItem != null)
        attackerHasKairosekiWeapon = false; 
    } 
    if (sourceOfDamage instanceof EntityLivingBase)
      if (entityIsLogia && !kairosekiChecks(entity) && !attackerHasHaki && !attackerHasKairosekiWeapon) {
        if (!MainConfig.enableLogiaInvulnerability)
          return; 
        if (entityUsedFruit.equalsIgnoreCase("gorogoro") && attackerUsedFruit.equalsIgnoreCase("gomugomu"))
          return; 
        event.setCanceled(true);
        WyNetworkHelper.sendToAllAround((IMessage)new PacketParticles("logiaEffect_" + entityUsedFruit, entity), entity.dimension, entity.posX, entity.posY, entity.posZ, 128.0D);
      } else if (sourceOfDamage instanceof EntityPlayer) {
        AbilityProperties abilityProps = AbilityProperties.get((EntityPlayer)sourceOfDamage);
        if (!sourceOfDamage.worldObj.isRemote && heldItem == null && !DevilFruitsHelper.checkForRestriction((EntityPlayer)sourceOfDamage))
          for (int i = 0; i < abilityProps.countAbilitiesInHotbar(); i++) {
            if (abilityProps.getAbilityFromSlot(i) != null && !abilityProps.getAbilityFromSlot(i).isOnCooldown() && abilityProps
              .getAbilityFromSlot(i).getAttribute().isPassive() && abilityProps.getAbilityFromSlot(i).isPassiveActive())
              if (abilityProps.getAbilityFromSlot(i).getAttribute().isPunch())
                abilityProps.getAbilityFromSlot(i).hitEntity((EntityPlayer)sourceOfDamage, entity);  
          }  
      }  
    if (sourceOfDamage instanceof net.minecraft.entity.projectile.EntityArrow && entityIsLogia && MainConfig.enableLogiaInvulnerability && !kairosekiChecks(entity))
      event.setCanceled(true); 
    if (sourceOfDamage instanceof AbilityProjectile && entityIsLogia && MainConfig.enableLogiaInvulnerability && !kairosekiChecks(entity)) {
      AbilityAttribute attr = ((AbilityProjectile)sourceOfDamage).getAttribute();
      ExtendedEntityData throwerProps = ExtendedEntityData.get(((EntityThrowable)sourceOfDamage).getThrower());
      if (attr.getAttributeName().equals("Bullet"))
        event.setCanceled(true); 
    } 
    if (event.source.isExplosion() && entityIsLogia && MainConfig.enableLogiaInvulnerability && !kairosekiChecks(entity))
      event.setCanceled(true); 
    if (entityUsedFruit.equalsIgnoreCase("meramera") && (damageSource.equals(DamageSource.inFire) || damageSource.equals(DamageSource.onFire))) {
      entity.extinguish();
      event.setCanceled(true);
    } 
    if (entityUsedFruit.equalsIgnoreCase("magumagu") && (damageSource.equals(DamageSource.inFire) || damageSource.equals(DamageSource.onFire) || event.source.equals(DamageSource.lava))) {
      entity.extinguish();
      event.setCanceled(true);
    } 
  }
  
  @SubscribeEvent
  public void onEntityLives(LivingEvent.LivingUpdateEvent event) {}
  
  private boolean kairosekiChecks(EntityLivingBase entity) {
    if (entity instanceof EntityPlayer) {
      EntityPlayer entityPlayer = (EntityPlayer)entity;
      return DevilFruitsHelper.isNearbyKairoseki(entityPlayer);
    } 
    return WyHelper.isBlockNearby(entity, 3, new Block[] { ListMisc.KairosekiBlock, ListMisc.KairosekiOre, ListMisc.KairosekiBars });
  }
}
